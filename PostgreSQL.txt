DROP DATABASE testdb  *для удаления базы данных
CREATE DATABASE test2db *создание базы данных


------------------------------------------СВЯЗИ ОДИН КО МНОГИМ------------------------------------------
---СОЗАДЕМ ТАБЛИЦЫ---
CREATE TABLE publisher
(
	publisher_id integer PRIMARY KEY,
	org_name varchar(128) NOT NULL,
	adress text NOT NULL
);

CREATE TABLE book
(
	book_id integer PRIMARY KEY,
	title text NOT NULL,
	isbn varchar(32) NOT NULL,
	fk_publisher_id integer REFERENCES publisher(publisher_id) NOT NULL
)

---УДАЛЕНИЕ ТАБЛИЦЫ---
DROP TABLE publisher;
DROP TABLE book

--ИЗВЛЕЧЕНИЕ ДАННЫХ---
SELECT *
FROM  book
(извлечение всех данных из таблицы)

---ПРИМЕР ЗАПОЛЕНИЯ ДАННЫМИ ТАБЛИЦЫ---
INSERT INTO book
VALUES 
(1, 'The Diry of a Young', '787897987', 1),
(2, 'Wride and Prejuidice', '909023223', 1),
(3, 'Fride and Prejuidice', '1209023223', 2),
(4, 'sride and Prejuidice', '209022431223', 2),
(5, 'Fride and Prejuidice', '30912323223', 2)

INSERT INTO publisher
VALUES
(1, 'Every''s Library', 'NY'),
(2, 'Dvery''s Library', 'NY'),
(3, 'Rvery''s Library', 'Wash'),
(4, 'Wvery''s Library', 'Chig')

---ИЗМЕННЕИЯ ТАБЛИЦЫ (ДОБАВЛЕНИЯ СТОЛБЦОВ И ДОБАВЛЕНИЕ ВНЕШНЕГО КЛЮЧА)---
ALTER TABLE book
ADD COLUMN fk_publisher_id;

ALTER TABLE book
ADD CONSTRAINT fk_publisher 
FOREIGN KEY (fk_publisher_id) REFERENCES publisher(publisher_id)  
# добавление внешнего ключа


------------------------------------------СВЯЗИ ОДИН К ОДНОМУ------------------------------------------
--СОЗДАНИЕ ТАБЛИЦЫ И ДОАВЛЕНИЕ СТОЛБЦА-----

ALTER TABLE passport
ADD COLUMN registration text NOT NULL

CREATE TABLE person
(
	person_id int PRIMARY KEY,
	firts_name varchar(64) NOT NULL,
	last_name varchar(64) NOT NULL
);

CREATE TABLE passport
(
	passport_id int PRIMARY KEY,
	serial_number int NOT NULL,
	fk_passport_person int REFERENCES person(person_id)
)

---ЗАПОЛЕНИЕ ТАБЛИЦЫ---
INSERT INTO person VALUES (1, 'Саня', 'Санькович');
INSERT INTO person VALUES (2, 'Олег', 'Олегович');
INSERT INTO person VALUES (3, 'Влад', 'Владович');

INSERT INTO passport VALUES (1, '54545', 1, 'Тула');
INSERT INTO passport VALUES (2, '4545', 2, 'Калуга');
INSERT INTO passport VALUES (3, '54545', 3, 'Москва');


-----Д.З.---03 Соединения - Joins-----

1. Найти заказчиков и обслуживающих их заказы сотрудников таких, что и заказчики и сотрудники из города London, а доставка идёт компанией Speedy Express. Вывести компанию заказчика и ФИО сотрудника.

SELECT customers.company_name, last_name, first_name
FROM customers
JOIN orders USING (customer_id)
JOIN employees USING (employee_id)
JOIN shippers ON orders.ship_via = shipper_id
WHERE customers.city = 'London' AND employees.city = 'London' 
AND shippers.company_name = 'Speedy Express'

2. Найти активные (см. поле discontinued) продукты из категории Beverages и Seafood, которых в продаже менее 20 единиц. Вывести наименование продуктов, кол-во единиц в продаже, имя контакта поставщика и его телефонный номер.

SELECT product_name, units_in_stock, contact_name, phone
FROM categories 
JOIN products USING (category_id)
JOIN suppliers USING (supplier_id)
WHERE (categories.category_name = 'Beverages' or categories.category_name = 'Seafood') 
AND products.discontinued = 0 AND units_in_stock < 20

3. Найти заказчиков, не сделавших ни одного заказа. Вывести имя заказчика и order_id.

SELECT contact_name, order_id
FROM customers
LEFT JOIN orders USING (customer_id)
WHERE order_id is NULL

4. Переписать предыдущий запрос, использовав симметричный вид джойна (подсказка: речь о LEFT и RIGHT).

SELECT contact_name, order_id
FROM orders
RIGHT JOIN customers USING (customer_id)
WHERE order_id is NULL

-----Д.З.---09 Функции SQL и PL_pgSQL-----
1. Создайте функцию, которая делает бэкап таблицы customers (копирует все данные в другую таблицу), предварительно стирая таблицу для бэкапа, если такая уже существует (чтобы в случае многократного запуска таблица для бэкапа перезатиралась).

CREATE OR REPLACE FUNCTION get_copy() RETURNS SETOF customers AS $$
	SELECT *
	FROM customers
$$ LANGUAGE SQL;

2. Создать функцию, которая возвращает средний фрахт (freight) по всем заказам

CREATE OR REPLACE FUNCTION get_avg_freight(OUT freight double precision) AS $$
	SELECT AVG(freight)
	FROM orders
$$ LANGUAGE SQL;

3. Написать функцию, которая принимает два целочисленных параметра, используемых как нижняя и верхняя границы для генерации случайного числа в пределах этой границы (включая сами граничные значения).

Функция random генерирует вещественное число от 0 до 1.

Необходимо вычислить разницу между границами и прибавить единицу.

На полученное число умножить результат функции random() и прибавить к результату значение нижней границы.

Применить функцию floor() к конечному результату, чтобы не "уехать" за границу и получить целое число.

CREATE OR REPLACE FUNCTION get_random(down int, up int, OUT result int) AS $$
BEGIN
	result := FLOOR(RANDOM()*(up-down)+down)
	RETURN;
END;	
$$ LANGUAGE plpgsql;

4. Создать функцию, которая возвращает самые низкую и высокую зарплаты среди сотрудников заданного города

DROP FUNCTION get_zp_employees
CREATE OR REPLACE FUNCTION get_zp_employees
(city_emp varchar, OUT min_zp real, OUT max_zp real) AS $$
	SELECT MIN(employees.extension::real), MAX(employees.extension::real)
	FROM employees
	WHERE city = city_emp
$$ LANGUAGE SQL;

SELECT * FROM get_zp_employees('London')

-----Д.З.---13 Массивы-----

Написать функцию, которая фильтрует телефонные номера по коду оператора.

Принимает 3-х значный код мобильного оператора и список телефонных номеров в формате +1(234)5678901 (variadic)

Функция возвращает только те номера, код оператора которых соответствует значению соответствующего аргумента.

Проверить функцию передав следующие аргументы:

903, +7(903)1901235, +7(926)8567589, +7(903)1532476

Попробовать передать аргументы с созданием массива и без.

Подсказка: чтобы передать массив в VARIADIC-аргумент, надо перед массивом прописать, собственно, ключевое слово variadic.

CREATE OR REPLACE FUNCTION telephone_number(code int,VARIADIC numbers text[]) RETURNS SETOF text AS $$
DECLARE
	tnumber text;
BEGIN
	FOREACH tnumber in ARRAY numbers
	LOOP
		IF tnumber LIKE CONCAT ('%', code::varchar, '%')  THEN RETURN NEXT tnumber;
		END IF;
	END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM telephone_number(926, '+7(903)1901235', '+7(926)8567589', '+7(903)1532476')

-----Д.З.---15 Продвинутая группировка с CUBE и ROLLUP-----

2. Вывести отчёт показывающий сумму продаж по сотрудникам и странам отгрузки с подытогами по сотрудникам и общим итогом.
SELECT orders.employee_id, ship_country, sum(unit_price * quantity) as suma
FROM order_details
JOIN orders USING (order_id)
GROUP BY ROLLUP (orders.employee_id, ship_country)
ORDER BY orders.employee_id, suma DESC


3. Вывести отчёт показывающий сумму продаж по сотрудникам, странам отгрузки, сотрудникам и странам отгрузки с подытогами по сотрудникам и общим итогом.
SELECT orders.employee_id, ship_country, sum(unit_price * quantity) as suma
FROM order_details
JOIN orders USING (order_id)
GROUP BY CUBE (orders.employee_id, ship_country)
ORDER BY orders.employee_id, suma

-----Д.З.---19 Оконные функции-----

1. Вывести отчёт показывающий по сотрудникам суммы продаж SUM(unit_price*quantity), и сопоставляющий их со средним значением суммы продаж по сотрудникам (AVG по SUM(unit_price*quantity)) сортированный по сумме продаж по убыванию.

SELECT DISTINCT employee_id, total, AVG(total) OVER() AS avg_price
FROM(
		SELECT employee_id, SUM(unit_price * quantity) OVER (PARTITION BY employee_id) as total
		FROM order_details
		JOIN orders USING (order_id)
	) q
ORDER BY total DESC;


2. Вывести ранг сотрудников по их зарплате, без пропусков. Также вывести имя, фамилию и должность.

SELECT last_name, first_name, title, employees.extension, 
DENSE_RANK() OVER(ORDER BY employees.extension DESC)
FROM employees
--если бы в employees.extension были значение типа int то сортировка была бы адекватной

-----Д.З.---20 Транзакции-----

1. В рамках транзакции с уровнем изоляции Repeatable Read выполнить следующие операции:

- заархивировать (SELECT INTO или CREATE TABLE AS) заказчиков, которые сделали покупок менее чем на 2000 у.е.
- удалить из таблицы заказчиков всех заказчиков, которые были предварительно заархивированы (подсказка: для этого придётся удалить данные из связанных таблиц)

BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

DROP TABLE IF EXISTS archive_poor_ccustomers;

CREATE TABLE archive_poor_ccustomers AS 
	SELECT customer_id, company_name, SUM(unit_price * quantity) AS total
	FROM orders
	JOIN order_details USING(order_id)
	JOIN customers USING(customer_id)
	GROUP BY company_name, customer_id
	HAVING SUM(unit_price * quantity) < 2000 --пост фильтр
	ORDER BY SUM(unit_price * quantity) DESC;
	
	DELETE FROM order_details
	WHERE order_id IN (SELECT order_id 
					   FROM orders
					   WHERE customer_id IN 
					   (SELECT customer_id FROM archive_poor_ccustomers)
						);
	DELETE FROM orders
	WHERE customer_id IN (SELECT customer_id FROM archive_poor_ccustomers);
	
	DELETE FROM customers
	WHERE customer_id IN (SELECT customer_id FROM archive_poor_ccustomers);

COMMIT;

END;

SELECT * FROM archive_poor_ccustomers



2. В рамках транзакции выполнить следующие операции:
- заархивировать все продукты, снятые с продажи (см. колонку discontinued)
- поставить savepoint после архивации
- удалить из таблицы продуктов все продукты, которые были заархивированы
- откатиться к savepoint
- закоммитить тразнакцию

BEGIN;

CREATE TABLE archive_discontinued_products AS
	SELECT * FROM products WHERE discontinued = 1;

SAVEPOINT archive_discontinued;

DELETE FROM order_details
WHERE product_id IN (SELECT product_id FROM archive_discontinued_products);

DELETE FROM products
WHERE discontinued = 1;

ROLLBACK TO archive_discontinued;

COMMIT;

SELECT * FROM archive_discontinued_products;
SELECT * FROM products WHERE discontinued = 1;


-----Д.З.---21 Триггеры-----


1. Автоматизировать логирование времени последнего изменения в таблице products. Добавить в products соответствующую колонку и реализовать построчный триггер.


ALTER TABLE products
ADD COLUMN last_updated timestamp;

CREATE OR REPLACE FUNCTION track_products_changes() RETURNS trigger AS $$
BEGIN
	NEW.last_updated = now();
	RETURN NEW;
END
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS products_timestamp ON products;
CREATE TRIGGER products_timestamp BEFORE INSERT OR UPDATE ON products
FOR EACH ROW EXECUTE PROCEDURE track_products_changes();

SELECT last_updated, * FROM products
WHERE product_id =2;

UPDATE products
SET unit_price = 19.05
WHERE product_id = 2;


2. Автоматизировать аудит операций в таблице order_details. Создайте отдельную таблицу для аудита, добавьте туда колонки для хранения наименования операций, имени пользователя и временного штампа. Реализуйте триггеры на утверждения.


DROP TABLE IF EXISTS order_details_audit;
CREATE TABLE order_details_audit (
	op char(1) NOT NULL,
	user_changed text NOT NULL,
	time_stamp timestamp NOT NULL,
	
	order_id smallint NOT NULL,
    product_id smallint NOT NULL,
    unit_price real NOT NULL,
    quantity smallint NOT NULL,
    discount real
);

CREATE OR REPLACE FUNCTION build_audit_order_details() RETURNS trigger AS $$
BEGIN
	IF TG_OP = 'INSERT' THEN
		INSERT INTO order_details_audit
		SELECT 'I', session_user, now(), nt.* FROM new_table nt;
		--session_user(имя пользователя, который находится в системе)
		--now() - функция текущей даты и времени
		--nt.* все остальные строчки взятые из новый таблицы, которую мы референсим new_table с псевдонимом nt
	ELSIF TG_OP = 'UPDATE' THEN
		INSERT INTO order_details_audit
		SELECT 'U', session_user, now(), nt.* FROM new_table nt;	
	ELSIF TG_OP = 'DELETE' THEN
		INSERT INTO order_details_audit
		SELECT 'D', session_user, now(), ot.* FROM old_table ot;
	END IF;
	RETURN NULL;
END
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS audit_order_details_insert ON order_details;
CREATE TRIGGER audit_order_details_insert AFTER INSERT ON order_details
REFERENCING NEW TABLE AS new_table
FOR EACH STATEMENT EXECUTE PROCEDURE build_audit_order_details();

DROP TRIGGER IF EXISTS audit_order_details_update ON order_details;
CREATE TRIGGER audit_order_details_update AFTER UPDATE ON order_details
REFERENCING NEW TABLE AS new_table
FOR EACH STATEMENT EXECUTE PROCEDURE build_audit_order_details();

DROP TRIGGER IF EXISTS audit_order_details_delete ON order_details;
CREATE TRIGGER audit_order_details_delete AFTER DELETE ON order_details
REFERENCING OLD TABLE AS old_table
FOR EACH STATEMENT EXECUTE PROCEDURE build_audit_order_details();

SELECT * FROM order_details ORDER BY order_id DESC;

INSERT INTO order_details (order_id, product_id, unit_price, quantity, discount)
VALUES (11077, 15, 40, 50, 0);

SELECT * FROM order_details_audit;

UPDATE order_details 
SET unit_price = 50
WHERE order_id = 11077;

DELETE FROM order_details
WHERE order_id = 11077;
